<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[第275天]]></title>
      <url>%2F2017%2F03%2F23%2FDiary_3%2F</url>
      <content type="text"><![CDATA[One day 分数线好高，压力max！！ 汤神说，年轻人要多吃点苦！！ 众筹买树！嗯！活久见！！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[链表操作（严蔚敏）]]></title>
      <url>%2F2017%2F03%2F23%2F%E9%93%BE%E8%A1%A8%E6%8F%92%E6%B3%95%E5%8F%8A%E5%BD%92%E5%B9%B6%2F</url>
      <content type="text"><![CDATA[链表插法及归并 123456789101112131415161718192021void CreateList(LinkList &amp;L, int i)/*逆位序（结点插在表头）输入n个元素的值，建立带表头结点的单链线性表L (头插法，该方法从一个空表开始，生成新结点，并将读取到的数据存放到新结点的数据域中，然后将新结点插入到当前链表的表头，即头结点之后*/&#123; //从表尾到表头逆向建立单链表L，每次均在头结点之后插入元素 int i; LinkList p; L = (LinkList)malloc(sizeof(LNode)); //生成头结点 L-&gt;next = NULL; //先建立一个带头结点的空单链表 printf("请输入%d个数据\n", n); for(i = n; i &gt; 0; --i) &#123; p = (LinkList)malloc(sizeof(LNode)); //生成新结点 scanf("%d", &amp;p-&gt;data); //将新结点插在表头 p-&gt;next = L-&gt;next; //将新结点插在表头 L-next = p; //头结点指向新结点 &#125; &#125; 1234567891011121314151617181920212223void CreateList1(LinkList &amp;L, int i) /*正位序，（结点插在表尾）输入n个元素的值，建立带表头结点的单链线性表L（尾插法）头插法建立单链表的算法虽然简单，但生成的链表中结点的次序和输入数据的顺序不一致。若希望两者次序一致，可采用尾插法。该方法是将新结点插入到当前链表的表尾上，为此必须增加一个尾指针r,使其始终指向当前链表的尾结点*/&#123; //从表头到表尾正向建立单链表L,每次均在表尾插入元素 int i; LinkLipst q, p; L = (LinkList)malloc(sizeof(LNode)); //生成头结点 L-&gt;next = NULL; //先建立一个带头结点的空单链表 q = L; //q指向空表的头结点 printf(&quot;请输入%d个数据\n&quot;, n); for(i = 1; i &lt;= n; i++) &#123; p = (LinkList)malloc(sizeof(LNode)); //生成头结点 scanf(&quot;%d&quot;, &amp;p-&gt;data); //给新结点输入元素值 q-&gt;next = p; //将新结点插在表尾 q = q-&gt;next; //q指向尾结点 &#125; p-&gt;next = NULL; //最后一个结点的指针域为空 &#125; 1234567891011121314151617181920212223242526void MergeList(LinkList La, LinkList &amp;Lb, LinkList &amp;Lc) //要对lb，lc进行操作 /*已知单链线性表la，lb的元素按值非递减排列归并la，lb得到新的线性表Lc，lc的元素也按照非递减排列（销毁lb，lc即是新的la） */ &#123; LinkList pa = La-&gt;next, pb = Lb-&gt;next, pc; //pa,pb分别指向la，lb的首元结点 Lc = pc = La; //用la的头结点作为lc的头结点，pc指la的头结点（lc的尾节点） while(pa &amp;&amp; pb) //La,Lb的元素都未比较完 if(pa-&gt;data &lt;= pb-&gt;data) //La的当前元素不大于la的当前元素 &#123; pc-&gt;next = pa; //将pa所值结点归并到lc中 pc = pa; //pc指向表lc的最后一个结点 pa = pa-&gt;next; //表la的下一个结点成为待比较结点 &#125; else //lb的当前元素小于la的当前元素 &#123; pc-&gt;next = pb; //将lb归并到lc中 pc = pb; //pc指向表lc的最后一个结点 pb = pb-&gt;next; //表lb的下一个结点成为待比较结点 &#125; pc-&gt;next = pa ? pa : pb; //插入剩余段 free(Lb); //释放lb的头结点 Lb = NULL; //lb不再指向任何结点 &#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[第276天]]></title>
      <url>%2F2017%2F03%2F22%2FDiary_2%2F</url>
      <content type="text"><![CDATA[One day 堕落！ Canon By Pachelbel!]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[链表操作（严蔚敏）]]></title>
      <url>%2F2017%2F03%2F22%2F%E9%93%BE%E8%A1%A8%E6%93%8D%E4%BD%9C%2F</url>
      <content type="text"><![CDATA[链表十二个函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275# include &lt;stdio.h&gt;# include &lt;stdlib.h&gt; //包含了exit函数 # define OVERFLOW -2 # define TRUE 1# define FALSE 0# define OK 1# define ERROR 0# define LIST_INIT_SIZE 10 //线性表存储空间的初始分配量 # define LIST_INCREMENT 2# define INFEASIBLE -1typedef int ElemType;typedef int Status; //定义结构体 struct LNode &#123; ElemType data; LNode * next;&#125;;typedef LNode * LinkList;/*链表的十二个函数操作 */void InitList(LinkList &amp;L) //构造一个空的线性表&#123; L = (LinkList)malloc(sizeof(LNode)); //产生头结点，并用L指向它 if(!L) //分配失败 exit(OVERFLOW); L-&gt;next = NULL; //头结点的指针域为空 &#125; void DestroyList(LinkList &amp;L) //销毁线性表，无头结点，L为NULL &#123; LinkList q; while(L) //L指向结点（非空） &#123; q = L-&gt;next; //q指向首元结点 free(L); //释放头结点 L = q; // L指向原首元结点，现头结点 &#125; &#125; void ClearList(LinkList L) //不改变L,将L置为空表 ，还有头指针与头结点 &#123; LinkList q = L-&gt;next; //q指向第一个结点 L-&gt;next = NULL; //头结点指针域为空 DestroyList(q); //销毁q所指向的链表 &#125; Status ListEmpty(LinkList L) //若L为空表返回true否则返回false &#123; if(L-&gt;next) return FALSE; else return TRUE;&#125; int ListLength(LinkList L) //返回L中元素的个数 &#123; int i = 0; //计数器初始值为0 LinkList p = L-&gt;next; //p指向第一个结点 while(p) //未到表尾 &#123; ++i; //计数器＋1 p = p-&gt;next; //p指向下一个结点 &#125; return i;&#125;Status GetElem(LinkList L,int i, ElemType &amp;e) //L为带头结点的单链表的头指针，当第i个元素存在时， 其值赋给e返回ok，否则返回false&#123; int j = 1; LinkList q = L-&gt;next; //q指向第一个结点 while(q &amp;&amp; j &lt; i) //当i不存在或者p指向第i个结点时退出循环（j==i） &#123; j++; //计数器加1 q = q-&gt;next; //q指向下一个结点 &#125; if(!q || j &gt; i) //第i个结点不存在 return ERROR; e = q-&gt;data; //第i个元素的值赋给e return OK; &#125; int LocateElem(LinkList L,ElemType e,Status(*compare)(ElemType,ElemType)) //返回L中第一个满足关系compare（）元素的位序，若不存在返回值为0 &#123; LinkList q = L-&gt;next; //q指向第一个元素 int i = 0; //计数器值为0 while(q) //未到表尾 &#123; i++; if(compare(q-&gt;data, e)) //这样的元素存在 return i; //返回位序 q = q-&gt;next; &#125; return 0; //这样的元素不存在 &#125;Status compare(ElemType a,ElemType s)&#123; if(a == s) return TRUE; else return FALSE;&#125;Status PriorElem(LinkList L, ElemType cur_e, ElemType &amp;pre_e) //若cur_e是L中的元素且不是第一个，用pre_e返回它的前驱返回ok否则操作失败返回error&#123; LinkList q, p = L-&gt;next; while(p &amp;&amp; p-&gt;next) //p所指的节点有后继 &#123; q = p-&gt;next; //q指向p的后继 if(q-&gt;data == cur_e) &#123; pre_e = p-&gt;data; return OK; &#125; p = q; //p的后继不是cur_e，p后移 &#125; return ERROR; &#125;Status NextElem(LinkList L, ElemType cur_e, ElemType &amp;next_e) //若cur_e是L中的元素且不是第一个，用next_e返回它的后继返回ok否则操作失败返回error&#123; LinkList q, p = L-&gt;next; while(p &amp;&amp; p-&gt;next) //p所指的结点有后继 &#123; if(p-&gt;data == cur_e) //找到cur_e这个元素 &#123; next_e = p-&gt;next-&gt;data; //返回它的值 return OK; &#125; p = p-&gt;next; //p指向下一个结点 &#125; return ERROR; &#125; Status ListInsert(LinkList L, int i, ElemType e) //在第i个位置之前插入e&#123; int j = 0; LinkList s, p = L; //p指向头结点（不是第一个结点） while(p &amp;&amp; j &lt; i - 1) //寻找第i-1个结点 &#123; j++; p = p-&gt;next; //p指向下一个结点 &#125; if(!p || j &gt; i - 1) return ERROR; s = (LinkList)malloc(sizeof(LNode)); //生成新的结点 s-&gt;data = e; //将e赋给新结点 s-&gt;next = p-&gt;next; //新结点指向原来第i个结点 p-&gt;next = s; //第i-1个结点指向新结点 return OK; &#125; Status ListDelete(LinkList L, int i, ElemType &amp;e) //不改变L，删除第i个元素，并用e返回其值&#123; int j = 0; LinkList q, p = L; while(p-&gt;next &amp;&amp; j &lt; i - 1) //删除操作是吧i-1个结点指向i+1个结点 ,找到i-1个结点或者到了表尾得时候 &#123; j++; p = p-&gt;next; &#125; if(!p-&gt;next || j &gt; i - 1) //删除位置不合理 return ERROR; q = p-&gt;next; //q指向被删除结点 p-&gt;next = q-&gt;next; //待删除结点的前驱指向待删除结点的后继 e = q-&gt;data; //将待删除结点的值赋给e free(q); return OK;&#125; void ListTraverse(LinkList L, void(* visit)(ElemType)) //对L中的每一个元素都调用visit函数 &#123; LinkList p = L-&gt;next; while(p) //p所指向的结点存在 &#123; visit (p-&gt;data); p = p-&gt;next; //p指向下一个结点 &#125; printf("\n"); &#125; void visit(ElemType c) /* 与main2-1.c不同 */ &#123; printf("%d ",c); &#125; int main(void) /* 除了几个输出语句外，主程和main2-1.c很像 */ &#123; LinkList L; /* 与main2-1.c不同 */ ElemType e,e0; Status i; int j,k; InitList(L); for(j=1;j&lt;=5;j++) i=ListInsert(L,1,j); printf("在L的表头依次插入1～5后：L="); ListTraverse(L,visit); /* 依次对元素调用visit()，输出元素的值 */ i=ListEmpty(L); printf("L是否空：i=%d(1:是 0:否)\n",i); ClearList(L); printf("清空L后：L="); ListTraverse(L,visit); i=ListEmpty(L); printf("L是否空：i=%d(1:是 0:否)\n",i); for(j=1;j&lt;=10;j++) ListInsert(L,j,j); printf("在L的表尾依次插入1～10后：L="); ListTraverse(L,visit); for(j=0;j&lt;=1;j++) &#123; k=LocateElem(L,j,compare); if(k) printf("第%d个元素的值为%d\n",k,j); else printf("没有值为%d的元素\n",j); &#125; for(j=1;j&lt;=2;j++) /* 测试头两个数据 */ &#123; GetElem(L,j,e0); /* 把第j个数据赋给e0 */ i=PriorElem(L,e0,e); /* 求e0的前驱 */ if(i==ERROR) printf("元素%d无前驱\n",e0); else printf("元素%d的前驱为：%d\n",e0,e); &#125; for(j=ListLength(L)-1; j&lt;=ListLength(L); j++)/*最后两个数据 */ &#123; GetElem(L,j,e0); /* 把第j个数据赋给e0 */ i=NextElem(L,e0,e); /* 求e0的后继 */ if(i==ERROR) printf("元素%d无后继\n",e0); else printf("元素%d的后继为：%d\n",e0,e); &#125; k=ListLength(L); /* k为表长 */ for(j=k+1;j&gt;=k;j--) &#123; i=ListDelete(L,j,e); /* 删除第j个数据 */ if(i==ERROR) printf("删除第%d个数据失败\n",j); else printf("删除的元素为：%d\n",e); &#125; printf("依次输出L的元素："); ListTraverse(L,visit); DestroyList(L); printf("销毁L后：L=%u\n",L); &#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[总线_2]]></title>
      <url>%2F2017%2F03%2F22%2F%E6%80%BB%E7%BA%BF_2%2F</url>
      <content type="text"><![CDATA[总线通信的四种方式 1.同步通信 总线同步通信也称为总线同步定时方式。 总线上的部件通过总线进行信息传送时，用一个公共的时钟信号进行同步，这种方式成为同步通信。这个公共的时钟可以由CPU总线控制部件发送到每一个部件（设备），也可以让每个部件有各自的时钟发生器，然而它们都必须有总线控制部件发出的时钟信号进行同步。由于采用了公共时钟，每个部件什么时候发送或接收信息都由统一的时钟规定，因此，同步通信具有较高的传输频率。 同步通信适用于总线长度较短、各部件存取时间比较接近的情况。这是因为， 同步方式对任何两个设备之间的通信都给予同样的时间安排。就总线长度来 讲，必须按距离最长的两个设备的传输延迟来设计公共时钟。但是总线长了 势必降低传输频率。存取时间是指部件接到读/写命令，到完成读出或写入一个数据所需要的时间。同步总线必须按最慢的部件设计公共时钟，如果各部件存取时间相差很大，也会损失总线效率。 2.异步通信 异步通信方式可分为不互锁、半互锁和全互锁三种类型: a.不互锁方式。主模块发出请求信号后，不等待接到从模块的回答信号，而是经过一段时间。确认从模块已收到请求信号后，便撤消其请求信号；从设备接到请求信号后，在条件允许时发出回答信号，并且经过一段时间，确认主设备已收到回答信号后，自动撤消回答信号。可见通信双方并无互锁关系。 b.半互锁方式。主模块发出请求信号，待接到从模块的回答信号后再撤消其请求信号，存在着简单的互锁关系：而从模块发出回答信号后，不等待主模块回答，在一段时间后便撤消其回答信号，无互锁关系。故称半互锁方式。 c.全互锁方式。主模块发出请求信号，待从模块回答后再撤其请求信号；从模块发出回答信号，待主模块获知后，再撤消其回答信号。故称全互锁方式 3.半同步通信 为解决异步通信方式对噪声敏感的问题，一般在异步总线中引入时钟信号，就绪和应答等定时信号都在时钟的上升沿有效，这样信号的有效时间限制在时钟到达的时刻，而不受其他时间的信号干扰。这种通信方式称为半同步通信方式。 4.分离式通信 基本思想：将一个传输操作事务分成两个子过程。在第一个子过程中，主控设备A在获得总线使用权后，将请求的事务类型（即总线命令）、地址以 及其他有关信息（如标识主控设备身份的编号等）发送到总线上，从设备B记录下这些信息。主控设备发完这些信息后便立即释放总线，这样其他设备便可使用总线。在第二个子过程中，从设备B收到主控设备A发来的信息后，就按照其请求的命令进行相应的操作，当准备好主控设备所需的数据后，从设备B便请求使用总线，一旦获得使用权，则从设备B就将主控设备A的编号及所需的数据等送到总线上，这样主控设备A便可接收数据。优点：提高整个系统的总有效带宽。缺点：控制相当复杂，开销大。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[总线_1]]></title>
      <url>%2F2017%2F03%2F22%2F%E6%80%BB%E7%BA%BF_1%2F</url>
      <content type="text"><![CDATA[总线基础概念 1.1.什么是总线 总线是连接各个部件的信息传输线，是各个部件共享的传输介质 2.1 总线的分类a.片内总线：芯片内部 的总线 b.系统总线 计算机各部件之间 的信息传输线 数据总线 双向 与机器字长、存储字长有关 地址总线 单向 与存储地址、 I/O地址有关 控制总线 有出 有入 c.通信总线：用于 计算机系统之间 或 计算机系统 与其他系统（如控制仪表、移动通信等之间的通信。 2.2传输方式 串行通信总线并行通信总线]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[大学问]]></title>
      <url>%2F2017%2F03%2F22%2F%E5%A4%A7%E5%AD%A6%E9%97%AE%2F</url>
      <content type="text"><![CDATA[By 林夕 知道什么叫天高地厚 内心的天空也要懂得探究 知道什么是海市蜃楼 人海的感受也要去进修 知识跟世界细水长流 智慧用思考照明宇宙 我们懂得学问没尽头 学会怎么做事再学做人的操守 我们懂得学习的理由 吸收是为了奉献才能承先启后 生命不止坚毅与奋斗 有梦想才是有意义的追求 成功不止付出与拥有 有承担才是最高的成就 知识跟世界细水长流 智慧用思考照明宇宙 我们懂得学问没尽头 学会怎么自救再学做人的操守 我们懂得学习的理由 力量要用来分享才能承先启后 我们懂得学问没尽头 学会终身学习才没辜负一番造就 我们懂得学习的理由 活出生命的光彩才无愧于春秋 我们懂得学习的理由 活出生命的光彩 才无愧于春秋]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[第277天]]></title>
      <url>%2F2017%2F03%2F21%2FDiary_1%2F</url>
      <content type="text"><![CDATA[One day 下雨下这么多天还真强，嗯！ 每天多学点少浪点一泄劲又得调整！ 数据结构好难！！！ 单词好容易忘！！！ 从来没有这么清楚想要什么！！ 明天加油！！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[顺序表的操作2 实现算法2.7（严蔚敏）]]></title>
      <url>%2F2017%2F03%2F21%2F%E5%AE%9E%E7%8E%B0%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%AE%97%E6%B3%952.7%2F</url>
      <content type="text"><![CDATA[实现线性表算法2.7 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140# include &lt;stdio.h&gt;# include &lt;stdlib.h&gt; //包含了exit函数 # define OVERFLOW -2 # define TURE 1# define FLASE 0# define OK 1# define ERROR 0# define LIST_INIT_SIZE 10 //线性表存储空间的初始分配量 # define LIST_INCREMENT 2typedef int ElemType; //分号不能丢 typedef int Status; void print1(ElemType a);Status ListInsert(struct Sqlist &amp;L, ElemType a, ElemType j);void ListTraverse(Sqlist &amp;L, void(* print1)(ElemType ));void InitList(Sqlist &amp;L);void MergeList(Sqlist La, Sqlist Lb, Sqlist &amp;Lc);struct Sqlist&#123; ElemType * elem; //储存空间基址 int length; //当前长度 int listsize; //当前分配的存储容量，以sizeof（ElemType）为单位 &#125;;int main(void)&#123; Sqlist La, Lb, Lc; int j; InitList(La); //创建空表La for(j = 1; j &lt;= 5; j++) &#123; ListInsert(La, j, j); //在表中插入5个元素依次为1，2，3，4，5 &#125; printf(&quot;La = &quot;); ListTraverse(La, print1); //对每个元素调用print1函数输出La的值 InitList(Lb); //创建空表b for(j = 1; j &lt;= 5; j++) &#123; ListInsert(Lb, j, j*2); //在表中插入5个元素依次为2，4，6，8，10 &#125; printf(&quot;Lb = &quot;); //输出表Lb的内容 ListTraverse(Lb, print1); MergeList(La, Lb, Lc); //由按非递减排列的表La，Lb得到按非递减排列的Lc printf(&quot;Lc = &quot;); //输出Lc的内容 ListTraverse(Lc, print1);&#125;void print1(ElemType a) //print1函数 &#123; printf(&quot;%d &quot;,a);&#125;Status ListInsert(struct Sqlist &amp;L, ElemType a, ElemType j)&#123; ElemType *q, *p, *newbase; if(a &lt; 1 || a &gt; L.length + 1) //a值不合法 return ERROR; if(L.length == L.listsize) //如果存储空间已满，则需要开辟新的空间 &#123; newbase = (ElemType *)realloc(L.elem, (L.listsize + LIST_INCREMENT) * sizeof(ElemType)); //为l.elem 追加长度 if (!newbase) exit(OVERFLOW); //分配失败 L.elem = newbase; L.listsize += LIST_INCREMENT; //增加存储容量 &#125; q = L.elem + a - 1; //q为插入位置 for(p = L.elem + L.length - 1; p &gt;= q; --p) //插入位置及以后的数据全部往后移，由表尾元素开始 &#123; *(p + 1) = *p; &#125; *q = j; L.length++; //表长加一 return OK;&#125;void InitList(Sqlist &amp;L) //算法2.3，构造一个空的顺序线性表L&#123; L.elem = (ElemType * )malloc(LIST_INIT_SIZE * sizeof(ElemType)); if(!L.elem) //存储空间分配失败 exit(OVERFLOW); //所在头文件：stdlib.h //功能: 关闭所有文件，终止正在执行的进程。 //exit(x) x==0表示正常退出，x!=0表示非正常退出 else L.length = 0; //空表长度为0 L.listsize = LIST_INIT_SIZE; //初始化存储容量 &#125;void ListTraverse(Sqlist &amp;L, void(* print1)(ElemType )) //不进行计算不要加&amp;&#123; ElemType *p = L.elem; //p指向第一个元素 int i; for(i = 1; i &lt;= L.length; i++) print1(*p++); printf(&quot;\n&quot;);&#125; void MergeList(Sqlist La, Sqlist Lb, Sqlist &amp;Lc)//1. 已知顺序线性表La和Lb的元素值按值非递减排列//2. 归并La，Lb得到新的顺序线性表Lc，Lc的值也不按非递减排列（不改变表La与Lb） &#123; ElemType *pa, *pa_last, *pb, *pb_last, *pc; pa =La.elem; //pa指向la的第一个元素 pb =Lb.elem; // pb指向lb的第一个元素 Lc.listsize = Lc.length = La.length + Lb.length; //不用InitList创建Lc pc = Lc.elem = (ElemType *)malloc(Lc.listsize * sizeof(ElemType)); if(!pc) exit(OVERFLOW); else pa_last = La.elem + La.length - 1; //指向最后一个元素 pb_last = Lb.elem + Lb.length - 1; while (pa &lt;= pa_last &amp;&amp; pb &lt;= pb_last ) //表la与表lb均有元素没有被归并 &#123; if(*pa &lt; *pb) //表la的元素不大于表lb的元素 *pc++ = *pa++; //将pa指向单元的值赋值给pc所指向的单元后，pa与pc分别加1 else *pc++ = *pb++; &#125;//以下while循环只有一个被执行 while(pa &lt;= pa_last) //表lb的元素全部被归并 *pc++ = *pa++; //插入表lb剩余元素 while(pb &lt;= pb_last) *pc++ = *pb++;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[顺序表的操作1（严蔚敏）]]></title>
      <url>%2F2017%2F03%2F20%2F%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%87%BD%E6%95%B0%E6%93%8D%E4%BD%9C(%E4%B8%A5%E8%94%9A%E6%95%8F%E7%89%88)%2F</url>
      <content type="text"><![CDATA[实现线性表多种函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301/*main2-1*/ # include &lt;stdio.h&gt;# include &lt;stdlib.h&gt; //包含了exit函数 # define OVERFLOW -2 # define TURE 1# define FLASE 0# define OK 1# define ERROR 0# define LIST_INIT_SIZE 10 //线性表存储空间的初始分配量 # define LIST_INCREMENT 2typedef int ElemType;typedef int Status; Status ListInsert(struct Sqlist &amp;L, int a, ElemType j);void InitList(Sqlist &amp;L);void print1(ElemType m);void ListTraverse(struct Sqlist L, void (* print1)(ElemType )); // 对表L中每个元素调用print1 Status ListEmpty(Sqlist L); void ClearList(Sqlist &amp;L);Status GetElem(Sqlist &amp;L, int i, ElemType &amp;e);Status LocateElem(Sqlist L, ElemType e, Status (* equal)(ElemType ,ElemType));Status equal(ElemType ,ElemType );Status PriorElem(Sqlist L,ElemType k,ElemType &amp;t);int ListLength (Sqlist L);Status NextElem (Sqlist L, ElemType cur_e, ElemType &amp;next_e);Status ListDelete(Sqlist &amp;L, int i, ElemType &amp;e);void DestroyList(Sqlist &amp;L);void db1(ElemType &amp;c);void ListTraverse2(struct Sqlist L, void (* db1)(ElemType &amp;));struct Sqlist&#123; ElemType * elem; //储存空间基址 int length; //当前长度 int listsize; //当前分配的存储容量，以sizeof（ElemType）为单位 &#125;; int main (void)&#123; struct Sqlist L; ElemType e, e0; Status i; //等价于int i； int k, j; InitList(L); printf(&quot;初始化L后，L.length = %d,L.listsize = %d,L.elem = %u\n&quot;,L.length ,L.listsize, L.elem); //%u是输入输出格式说明符,表示按unsigned int格式输入或输出数据 for(j=1; j&lt;=5; j++) i = ListInsert(L, 1 ,j); //在L的表头插入j printf(&quot;在L的表头依次插入1~5后，*L.elem = &quot;); for(j = 1; j &lt;= 5; j++) printf(&quot;%d&quot;,*(L.elem+j-1)); //依次输出表L中的元素 printf(&quot;\n调用ListTraverse()函数，依次输出表L中的元素：&quot;); ListTraverse(L, print1); //依次对表L中的元素调用print1函数（输出元素值） // 没有改变线性表L里的属性值，不必传指针类型，传变量类型即可 i = ListEmpty(L); // 检测表L是否为空 printf(&quot;L.length = %d,L.listsize = %d(不变),&quot;,L.length, L.listsize); printf(&quot;L.elem = %u(不变),L是否为空？i = %d\n&quot;,L.elem, i); ClearList(L); //清空表L i = ListEmpty(L); //再次检测表L是否为空 printf(&quot;清空L后，L.length = %d,L.listsize = %d,&quot;,L.length, L.listsize); printf(&quot;L.elem = %u,L是否为空？i = %d\n&quot;,L.elem, i); for(j=1; j&lt;=10; j++) ListInsert(L,j,j); //在L的表尾插入j printf(&quot;在L的表尾依次插入1~10后，L=&quot;); ListTraverse(L,print1); //依次输出表L中的元素 printf(&quot;L.length = %d,L.listsize = %d,L.elem = %u\n&quot;,L.length ,L.listsize, L.elem); ListInsert(L,1,0); //在表头插入0这个元素，增加存储空间 printf(&quot;在表头插入0后，L.length = %d,L.listsize = %d(改变),L.elem = %u(可能改变)\n&quot;,L.length, L.listsize, L.elem); GetElem(L,5,e); //把第五个元素赋给e printf(&quot;第五个元素的值为%d\n&quot;,e); for(j=10; j&lt;=11; j++) &#123; k = LocateElem(L, j, equal); //查找表l中与j相等的元素，并将其位序赋给k if(k) //k不为0，说明有符合条件的元素存在 printf(&quot;第%d个元素的值是%d\n&quot;,k, j); else //k=0，没有符合条件的元素 printf(&quot;没有值为%d的元素\n&quot;,j); &#125; for(j=3; j&lt;4; j++) &#123; k = LocateElem(L, j*j, equal); //查找表中是否有与j平方相等的数据 if(k) //k不为0，说明有符合条件的元素存在 printf(&quot;第%d个元素的值是%d的平方\n&quot;,k, j); else //k=0，没有符合条件的元素 printf(&quot;没有值为%d平方的元素\n&quot;,j); &#125; for(j=1; j&lt;2; j++) &#123; GetElem(L, j, e0); //把表中第j哥元素赋给e0 i = PriorElem(L,e0,e); //求e0的前驱，如果成功，赋值给e if(i==ERROR) //操作失败 printf(&quot;元素%d无前驱，&quot;,e0); else printf(&quot;元素%d的前驱为%d\n&quot;,e0,e); &#125; for(j = ListLength(L) - 1; j &lt;= ListLength(L); j++) &#123; GetElem(L, j, e0); //将表中的第j个元素赋给e0 i = NextElem(L, e0, e); //求e0的后继，如果成功将值赋给e if(i == ERROR) &#123; printf(&quot;元素%d无后继\n&quot;,e0); &#125; else printf(&quot;元素%d的后继为%d,&quot;,e0, e); &#125; k = ListLength(L); for(j = k + 1; j &gt;= k; j--) &#123; i = ListDelete(L, j, e); //删除第j个元素 if(i == ERROR) printf(&quot;删除第%d个元素失败。&quot;,j); else printf(&quot;删除第%d个元素成功，其值为%d&quot;, j, e); &#125; ListTraverse2(L, db1); //对元素调用db1函数，元素值乘2 printf(&quot;L的元素值加倍后，L = &quot;); ListTraverse(L, print1); //输出L的元素值 DestroyList(L); printf(&quot;销毁L后，L.length = %d, L.listsize = %d, L.elem = %u\n&quot;,L.length, L.listsize, L.elem); &#125; Status ListDelete(Sqlist &amp;L, int i, ElemType &amp;e) //删除第i个元素并用e返回其值 &#123; ElemType *p, *q; if(i&lt;1 || i&gt;L.length) return ERROR; else p = L.elem + i - 1; //q指向被删除的元素 e = *p; //被删除的元素值赋给e q = L.elem + L.length + 1; for(p++; p&lt;+q; p++) *(p - 1) = *p; L.length--; return OK; &#125;void ListTraverse2(struct Sqlist L, void (* db1)(ElemType &amp;)) /*指向函数的指针 对表L中每个元素调用print1 */ &#123; ElemType *p = L.elem; //p指向第一个元素 int i; for(i = 1; i &lt;= L.length; i++) db1(*p++); printf(&quot;\n&quot;);&#125; void db1(ElemType &amp;c)&#123; c *= 2;&#125;void DestroyList(Sqlist &amp;L)&#123; free(L.elem); L.elem = NULL; L.length = 0; L.listsize = 0; &#125;int ListLength (Sqlist L) //返回L中数据元素的个数 &#123; return L.length;&#125;Status NextElem (Sqlist L, ElemType cur_e, ElemType &amp;next_e)/* 若cur_e是L中的元素，且不是最后一个，则用next_e返回他的后继 否则操作失败，next_e无定义 */&#123; int i = 1; ElemType *p = L.elem; //p指向第一个元素 while(i &lt;= L.length &amp;&amp; *p != cur_e) //i未到表尾且没有找到值为cur_e的元素 &#123; p++; //p指向下一个元素 i++; //计数加1 &#125; if(i == L.length) return ERROR; //操作失败 else //找到值为cur_e的元素，并由p指向其 &#123; next_e = *++p; //p指向下一个元素即后继 return OK; &#125; &#125; Status PriorElem(Sqlist L,ElemType k,ElemType &amp;t)&#123; int i = 2; ElemType * p = L.elem + 1; //p指向第二个元素 while(i&lt;=L.length &amp;&amp; * p != k) //在表长范围内且未找到eo的元素 &#123; p++; i++; &#125; if(i&gt;L.length) return ERROR; else //找到了值为e0的元素 &#123; t = *p-- ; return OK; &#125; &#125;Status equal(ElemType a,ElemType s)&#123; if(a == s) return TURE; else return FLASE;&#125;Status LocateElem(Sqlist L, ElemType e, Status (* equal)(ElemType ,ElemType))&#123; int i = 1; ElemType * p = L.elem; //p的初始值为第一个元素地址 while(i&lt;=L.length &amp;&amp; !equal(*p++,e)) //i未超出表的范围并且没找到符合条件的数据 i++; if(i&lt;=L.length) //找到了符合条件的数据 return i; //返回位序i else return 0; &#125;Status GetElem(Sqlist &amp;L, int i, ElemType &amp;e) //要改变e的值必须发送地址 &#123; if(i&lt;1 || i&gt;L.length) //i不在表L的范围内 return ERROR; else e = *(L.elem + i - 1); return OK;&#125; void ClearList(Sqlist &amp;L) //将表l置为空表 &#123; L.length = 0;&#125;Status ListEmpty(Sqlist L) //如果L为空表，则返回TURE 否则返回FLASE &#123; if(L.length == 0) return TURE; else return FLASE;&#125; void print1(ElemType m) //print1函数 &#123; printf(&quot;%d &quot;,m);&#125;void ListTraverse(struct Sqlist L, void (* print1)(ElemType ) ) /*指向函数的指针 对表L中每个元素调用print1 */ &#123; ElemType *p = L.elem; //p指向第一个元素 int i; for(i = 1; i &lt;= L.length; i++) print1(*p++); printf(&quot;\n&quot;);&#125; Status ListInsert(struct Sqlist &amp;L, ElemType a, ElemType j)&#123; ElemType *q, *p, *newbase; if(a &lt; 1 || a &gt; L.length + 1) //a值不合法 return ERROR; if(L.length == L.listsize) //如果存储空间已满，则需要开辟新的空间 &#123; newbase = (ElemType *)realloc(L.elem, (L.listsize + LIST_INCREMENT) * sizeof(ElemType)); //为l.elem 追加长度 if (!newbase) exit(OVERFLOW); //分配失败 L.elem = newbase; L.listsize += LIST_INCREMENT; //增加存储容量 &#125; q = L.elem + a - 1; //q为插入位置 for(p = L.elem + L.length - 1; p &gt;= q; --p) //插入位置及以后的数据全部往后移，由表尾元素开始 &#123; *(p + 1) = *p; &#125; *q = j; L.length++; //表长加一 return OK;&#125;void InitList(Sqlist &amp;L) //算法2.3，构造一个空的顺序线性表L&#123; L.elem = (ElemType * )malloc(LIST_INIT_SIZE * sizeof(ElemType)); if(!L.elem) //存储空间分配失败 exit(OVERFLOW); /* 所在头文件：stdlib.h 功能: 关闭所有文件，终止正在执行的进程。 exit(x) x==0表示正常退出，x!=0表示非正常退出 */ else L.length = 0; //空表长度为0 L.listsize = LIST_INIT_SIZE; //初始化存储容量 &#125;]]></content>
    </entry>

    
  
  
</search>
