<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[顺序表的操作2 实现算法2.7（严蔚敏）]]></title>
      <url>%2F2017%2F03%2F21%2F%E5%AE%9E%E7%8E%B0%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%AE%97%E6%B3%952.7%2F</url>
      <content type="text"><![CDATA[实现线性表算法2.7 ‘’’c #include #include //包含了exit函数 #define OVERFLOW -2 #define TURE 1 #define FLASE 0 #define OK 1 #define ERROR 0 #define LIST_INIT_SIZE 10 //线性表存储空间的初始分配量 #define LIST_INCREMENT 2typedef int ElemType; //分号不能丢typedef int Status; void print1(ElemType a);Status ListInsert(struct Sqlist &amp;L, ElemType a, ElemType j);void ListTraverse(Sqlist &amp;L, void(* print1)(ElemType ));void InitList(Sqlist &amp;L);void MergeList(Sqlist La, Sqlist Lb, Sqlist &amp;Lc); struct Sqlist{ ElemType * elem; //储存空间基址 int length; //当前长度 int listsize; //当前分配的存储容量，以sizeof（ElemType）为单位}; int main(void){ Sqlist La, Lb, Lc; int j; InitList(La); //创建空表La for(j = 1; j &lt;= 5; j++) { ListInsert(La, j, j); //在表中插入5个元素依次为1，2，3，4，5 } printf(“La = “); ListTraverse(La, print1); //对每个元素调用print1函数输出La的值 InitList(Lb); //创建空表b for(j = 1; j &lt;= 5; j++) { ListInsert(Lb, j, j*2); //在表中插入5个元素依次为2，4，6，8，10 } printf(&quot;Lb = &quot;); //输出表Lb的内容 ListTraverse(Lb, print1); MergeList(La, Lb, Lc); //由按非递减排列的表La，Lb得到按非递减排列的Lc printf(&quot;Lc = &quot;); //输出Lc的内容 ListTraverse(Lc, print1); } void print1(ElemType a) //print1函数{ printf(“%d “,a);} Status ListInsert(struct Sqlist &amp;L, ElemType a, ElemType j){ ElemType q, p, newbase; if(a &lt; 1 || a &gt; L.length + 1) //a值不合法 return ERROR; if(L.length == L.listsize) //如果存储空间已满，则需要开辟新的空间 { newbase = (ElemType )realloc(L.elem, (L.listsize + LIST_INCREMENT) * sizeof(ElemType)); //为l.elem 追加长度 if (!newbase) exit(OVERFLOW); //分配失败 L.elem = newbase; L.listsize += LIST_INCREMENT; //增加存储容量 } q = L.elem + a - 1; //q为插入位置 for(p = L.elem + L.length - 1; p &gt;= q; --p) //插入位置及以后的数据全部往后移，由表尾元素开始 { *(p + 1) = *p; } *q = j; L.length++; //表长加一 return OK; }void InitList(Sqlist &amp;L) //算法2.3，构造一个空的顺序线性表L{ L.elem = (ElemType )malloc(LIST_INIT_SIZE sizeof(ElemType)); if(!L.elem) //存储空间分配失败 exit(OVERFLOW); / 所在头文件：stdlib.h 功能: 关闭所有文件，终止正在执行的进程。 exit(x) x==0表示正常退出，x!=0表示非正常退出 / else L.length = 0; //空表长度为0 L.listsize = LIST_INIT_SIZE; //初始化存储容量} void ListTraverse(Sqlist &amp;L, void( print1)(ElemType )) //不进行计算不要加&amp;{ ElemType p = L.elem; //p指向第一个元素 int i; for(i = 1; i &lt;= L.length; i++) print1(*p++); printf(“\n”);} void MergeList(Sqlist La, Sqlist Lb, Sqlist &amp;Lc)/* 已知顺序线性表La和Lb的元素值按值非递减排列 归并La，Lb得到新的顺序线性表Lc，Lc的值也不按非递减排列（不改变表La与Lb）/{ ElemType pa, pa_last, pb, pb_last, pc; pa =La.elem; //pa指向la的第一个元素 pb =Lb.elem; // pb指向lb的第一个元素 Lc.listsize = Lc.length = La.length + Lb.length; //不用InitList创建Lc pc = Lc.elem = (ElemType )malloc(Lc.listsize sizeof(ElemType)); if(!pc) exit(OVERFLOW); else pa_last = La.elem + La.length - 1; //指向最后一个元素 pb_last = Lb.elem + Lb.length - 1; while (pa &lt;= pa_last &amp;&amp; pb &lt;= pb_last ) //表la与表lb均有元素没有被归并 { if(*pa &lt; *pb) //表la的冤死不大于表lb的元素 *pc++ = *pa++; //将pa指向单元的值赋值给pc所指向的单元后，pa与pc分别加1 else *pc++ = *pb++; }//一下像个while循环只有一个被执行 while(pa &lt;= pa_last) //表lb的元素全部被归并 *pc++ = *pa++; //插入表lb剩余元素 while(pb &lt;= pb_last) *pc++ = *pb++; }‘’’]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[顺序表的操作（严蔚敏）]]></title>
      <url>%2F2017%2F03%2F20%2F%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%87%BD%E6%95%B0%E6%93%8D%E4%BD%9C(%E4%B8%A5%E8%94%9A%E6%95%8F%E7%89%88)%2F</url>
      <content type="text"><![CDATA[实现线性表多种函数 ‘’’/main2-1/ #include #include //包含了exit函数 #define OVERFLOW -2 #define TURE 1 #define FLASE 0 #define OK 1 #define ERROR 0 #define LIST_INIT_SIZE 10 //线性表存储空间的初始分配量 #define LIST_INCREMENT 2typedef int ElemType;typedef int Status; Status ListInsert(struct Sqlist &amp;L, int a, ElemType j);void InitList(Sqlist &amp;L);void print1(ElemType m);void ListTraverse(struct Sqlist L, void ( print1)(ElemType )); // 对表L中每个元素调用print1Status ListEmpty(Sqlist L);void ClearList(Sqlist &amp;L);Status GetElem(Sqlist &amp;L, int i, ElemType &amp;e);Status LocateElem(Sqlist L, ElemType e, Status ( equal)(ElemType ,ElemType));Status equal(ElemType ,ElemType );Status PriorElem(Sqlist L,ElemType k,ElemType &amp;t);int ListLength (Sqlist L);Status NextElem (Sqlist L, ElemType cur_e, ElemType &amp;next_e);Status ListDelete(Sqlist &amp;L, int i, ElemType &amp;e);void DestroyList(Sqlist &amp;L);void db1(ElemType &amp;c);void ListTraverse2(struct Sqlist L, void (* db1)(ElemType &amp;)); struct Sqlist{ ElemType * elem; //储存空间基址 int length; //当前长度 int listsize; //当前分配的存储容量，以sizeof（ElemType）为单位}; int main (void){ struct Sqlist L; ElemType e, e0; Status i; //等价于int i； int k, j; InitList(L); printf(“初始化L后，L.length = %d,L.listsize = %d,L.elem = %u\n”,L.length ,L.listsize, L.elem); //%u是输入输出格式说明符,表示按unsigned int格式输入或输出数据 for(j=1; j&lt;=5; j++) i = ListInsert(L, 1 ,j); //在L的表头插入j printf(“在L的表头依次插入1~5后，L.elem = “); for(j = 1; j &lt;= 5; j++) printf(“%d”,(L.elem+j-1)); //依次输出表L中的元素 printf(“\n调用ListTraverse()函数，依次输出表L中的元素：”); ListTraverse(L, print1); //依次对表L中的元素调用print1函数（输出元素值） // 没有改变线性表L里的属性值，不必传指针类型，传变量类型即可 i = ListEmpty(L); // 检测表L是否为空 printf(“L.length = %d,L.listsize = %d(不变),”,L.length, L.listsize); printf(“L.elem = %u(不变),L是否为空？i = %d\n”,L.elem, i); ClearList(L); //清空表L i = ListEmpty(L); //再次检测表L是否为空 printf(&quot;清空L后，L.length = %d,L.listsize = %d,&quot;,L.length, L.listsize); printf(&quot;L.elem = %u,L是否为空？i = %d\n&quot;,L.elem, i); for(j=1; j&lt;=10; j++) ListInsert(L,j,j); //在L的表尾插入j printf(&quot;在L的表尾依次插入1~10后，L=&quot;); ListTraverse(L,print1); //依次输出表L中的元素 printf(&quot;L.length = %d,L.listsize = %d,L.elem = %u\n&quot;,L.length ,L.listsize, L.elem); ListInsert(L,1,0); //在表头插入0这个元素，增加存储空间 printf(&quot;在表头插入0后，L.length = %d,L.listsize = %d(改变),L.elem = %u(可能改变)\n&quot;,L.length, L.listsize, L.elem); GetElem(L,5,e); //把第五个元素赋给e printf(&quot;第五个元素的值为%d\n&quot;,e); for(j=10; j&lt;=11; j++) { k = LocateElem(L, j, equal); //查找表l中与j相等的元素，并将其位序赋给k if(k) //k不为0，说明有符合条件的元素存在 printf(&quot;第%d个元素的值是%d\n&quot;,k, j); else //k=0，没有符合条件的元素 printf(&quot;没有值为%d的元素\n&quot;,j); } for(j=3; j&lt;4; j++) { k = LocateElem(L, j*j, equal); //查找表中是否有与j平方相等的数据 if(k) //k不为0，说明有符合条件的元素存在 printf(&quot;第%d个元素的值是%d的平方\n&quot;,k, j); else //k=0，没有符合条件的元素 printf(&quot;没有值为%d平方的元素\n&quot;,j); } for(j=1; j&lt;2; j++) { GetElem(L, j, e0); //把表中第j哥元素赋给e0 i = PriorElem(L,e0,e); //求e0的前驱，如果成功，赋值给e if(i==ERROR) //操作失败 printf(&quot;元素%d无前驱，&quot;,e0); else printf(&quot;元素%d的前驱为%d\n&quot;,e0,e); } for(j = ListLength(L) - 1; j &lt;= ListLength(L); j++) { GetElem(L, j, e0); //将表中的第j个元素赋给e0 i = NextElem(L, e0, e); //求e0的后继，如果成功将值赋给e if(i == ERROR) { printf(&quot;元素%d无后继\n&quot;,e0); } else printf(&quot;元素%d的后继为%d,&quot;,e0, e); } k = ListLength(L); for(j = k + 1; j &gt;= k; j--) { i = ListDelete(L, j, e); //删除第j个元素 if(i == ERROR) printf(&quot;删除第%d个元素失败。&quot;,j); else printf(&quot;删除第%d个元素成功，其值为%d&quot;, j, e); } ListTraverse2(L, db1); //对元素调用db1函数，元素值乘2 printf(&quot;L的元素值加倍后，L = &quot;); ListTraverse(L, print1); //输出L的元素值 DestroyList(L); printf(&quot;销毁L后，L.length = %d, L.listsize = %d, L.elem = %u\n&quot;,L.length, L.listsize, L.elem); }Status ListDelete(Sqlist &amp;L, int i, ElemType &amp;e) //删除第i个元素并用e返回其值{ ElemType p, q; if(iL.length) return ERROR; else p = L.elem + i - 1; //q指向被删除的元素 e = p; //被删除的元素值赋给e q = L.elem + L.length + 1; for(p++; p&lt;+q; p++) (p - 1) = *p; L.length–; return OK; }void ListTraverse2(struct Sqlist L, void ( db1)(ElemType &amp;)) /指向函数的指针 对表L中每个元素调用print1 /{ ElemType p = L.elem; //p指向第一个元素 int i; for(i = 1; i &lt;= L.length; i++) db1(p++); printf(“\n”);}void db1(ElemType &amp;c){ c = 2;}void DestroyList(Sqlist &amp;L){ free(L.elem); L.elem = NULL; L.length = 0; L.listsize = 0;}int ListLength (Sqlist L) //返回L中数据元素的个数{ return L.length;}Status NextElem (Sqlist L, ElemType cur_e, ElemType &amp;next_e)/ 若cur_e是L中的元素，且不是最后一个，则用next_e返回他的后继 否则操作失败，next_e无定义 /{ int i = 1; ElemType p = L.elem; //p指向第一个元素 while(i &lt;= L.length &amp;&amp; p != cur_e) //i未到表尾且没有找到值为cur_e的元素 { p++; //p指向下一个元素 i++; //计数加1 } if(i == L.length) return ERROR; //操作失败 else //找到值为cur_e的元素，并由p指向其 { next_e = *++p; //p指向下一个元素即后继 return OK; }} Status PriorElem(Sqlist L,ElemType k,ElemType &amp;t){ int i = 2; ElemType p = L.elem + 1; //p指向第二个元素 while(i&lt;=L.length &amp;&amp; p != k) //在表长范围内且未找到eo的元素 { p++; i++; } if(i&gt;L.length) return ERROR; else //找到了值为e0的元素 { t = *p– ; return OK; } }Status equal(ElemType a,ElemType s){ if(a == s) return TURE; else return FLASE;}Status LocateElem(Sqlist L, ElemType e, Status ( equal)(ElemType ,ElemType)){ int i = 1; ElemType p = L.elem; //p的初始值为第一个元素地址 while(i&lt;=L.length &amp;&amp; !equal(*p++,e)) //i未超出表的范围并且没找到符合条件的数据 i++; if(i&lt;=L.length) //找到了符合条件的数据 return i; //返回位序i else return 0;}Status GetElem(Sqlist &amp;L, int i, ElemType &amp;e) //要改变e的值必须发送地址{ if(i&lt;1 || i&gt;L.length) //i不在表L的范围内 return ERROR; else e = *(L.elem + i - 1); return OK; }void ClearList(Sqlist &amp;L) //将表l置为空表{ L.length = 0;}Status ListEmpty(Sqlist L) //如果L为空表，则返回TURE 否则返回FLASE{ if(L.length == 0) return TURE; else return FLASE;} void print1(ElemType m) //print1函数{ printf(“%d “,m);}void ListTraverse(struct Sqlist L, void ( print1)(ElemType ) ) /指向函数的指针 对表L中每个元素调用print1 /{ ElemType p = L.elem; //p指向第一个元素 int i; for(i = 1; i &lt;= L.length; i++) print1(*p++); printf(“\n”);} Status ListInsert(struct Sqlist &amp;L, ElemType a, ElemType j){ ElemType q, p, newbase; if(a &lt; 1 || a &gt; L.length + 1) //a值不合法 return ERROR; if(L.length == L.listsize) //如果存储空间已满，则需要开辟新的空间 { newbase = (ElemType )realloc(L.elem, (L.listsize + LIST_INCREMENT) * sizeof(ElemType)); //为l.elem 追加长度 if (!newbase) exit(OVERFLOW); //分配失败 L.elem = newbase; L.listsize += LIST_INCREMENT; //增加存储容量 } q = L.elem + a - 1; //q为插入位置 for(p = L.elem + L.length - 1; p &gt;= q; --p) //插入位置及以后的数据全部往后移，由表尾元素开始 { *(p + 1) = *p; } *q = j; L.length++; //表长加一 return OK; } void InitList(Sqlist &amp;L) //算法2.3，构造一个空的顺序线性表L{ L.elem = (ElemType )malloc(LIST_INIT_SIZE sizeof(ElemType)); if(!L.elem) //存储空间分配失败 exit(OVERFLOW); / 所在头文件：stdlib.h 功能: 关闭所有文件，终止正在执行的进程。 exit(x) x==0表示正常退出，x!=0表示非正常退出 / else L.length = 0; //空表长度为0 L.listsize = LIST_INIT_SIZE; //初始化存储容量} ‘’’]]></content>
    </entry>

    
  
  
</search>
