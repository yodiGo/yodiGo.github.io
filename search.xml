<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[总线_2]]></title>
      <url>%2F2017%2F03%2F22%2F%E6%80%BB%E7%BA%BF_2%2F</url>
      <content type="text"><![CDATA[总线通信的四种方式 1.同步通信 总线同步通信也称为总线同步定时方式。 总线上的部件通过总线进行信息传送时，用一个公共的时钟信号进行同步，这种方式成为同步通信。这个公共的时钟可以由CPU总线控制部件发送到每一个部件（设备），也可以让每个部件有各自的时钟发生器，然而它们都必须有总线控制部件发出的时钟信号进行同步。由于采用了公共时钟，每个部件什么时候发送或接收信息都由统一的时钟规定，因此，同步通信具有较高的传输频率。 同步通信适用于总线长度较短、各部件存取时间比较接近的情况。这是因为， 同步方式对任何两个设备之间的通信都给予同样的时间安排。就总线长度来 讲，必须按距离最长的两个设备的传输延迟来设计公共时钟。但是总线长了 势必降低传输频率。存取时间是指部件接到读/写命令，到完成读出或写入一个数据所需要的时间。同步总线必须按最慢的部件设计公共时钟，如果各部件存取时间相差很大，也会损失总线效率。 2.异步通信 异步通信方式可分为不互锁、半互锁和全互锁三种类型: a.不互锁方式。主模块发出请求信号后，不等待接到从模块的回答信号，而是经过一段时间。确认从模块已收到请求信号后，便撤消其请求信号；从设备接到请求信号后，在条件允许时发出回答信号，并且经过一段时间，确认主设备已收到回答信号后，自动撤消回答信号。可见通信双方并无互锁关系。 b.半互锁方式。主模块发出请求信号，待接到从模块的回答信号后再撤消其请求信号，存在着简单的互锁关系：而从模块发出回答信号后，不等待主模块回答，在一段时间后便撤消其回答信号，无互锁关系。故称半互锁方式。 c.全互锁方式。主模块发出请求信号，待从模块回答后再撤其请求信号；从模块发出回答信号，待主模块获知后，再撤消其回答信号。故称全互锁方式 3.半同步通信 为解决异步通信方式对噪声敏感的问题，一般在异步总线中引入时钟信号，就绪和应答等定时信号都在时钟的上升沿有效，这样信号的有效时间限制在时钟到达的时刻，而不受其他时间的信号干扰。这种通信方式称为半同步通信方式。 4.分离式通信 基本思想：将一个传输操作事务分成两个子过程。在第一个子过程中，主控设备A在获得总线使用权后，将请求的事务类型（即总线命令）、地址以 及其他有关信息（如标识主控设备身份的编号等）发送到总线上，从设备B记录下这些信息。主控设备发完这些信息后便立即释放总线，这样其他设备便可使用总线。在第二个子过程中，从设备B收到主控设备A发来的信息后，就按照其请求的命令进行相应的操作，当准备好主控设备所需的数据后，从设备B便请求使用总线，一旦获得使用权，则从设备B就将主控设备A的编号及所需的数据等送到总线上，这样主控设备A便可接收数据。 优点：提高整个系统的总有效带宽。 缺点：控制相当复杂，开销大。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[总线_1]]></title>
      <url>%2F2017%2F03%2F22%2F%E6%80%BB%E7%BA%BF_1%2F</url>
      <content type="text"><![CDATA[1.1.什么是总线总线是连接各个部件的信息传输线，是 各个部件共享的传输介质 2.1 总线的分类 a.片内总线：芯片内部 的总线 b.系统总线：计算机各部件之间 的信息传输线 数据总线 双向 与机器字长、存储字长有关 地址总线 单向 与存储地址、 I/O地址有关 控制总线 有出 有入 c.通信总线：用于 计算机系统之间 或 计算机系统 与其他系统（如控制仪表、移动通信等之间的通信。 2.2传输方式 串行通信总线 并行通信总线]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[大学问]]></title>
      <url>%2F2017%2F03%2F22%2F%E5%A4%A7%E5%AD%A6%E9%97%AE%2F</url>
      <content type="text"><![CDATA[知道什么叫天高地厚 内心的天空也要懂得探究 知道什么是海市蜃楼 人海的感受也要去进修 知识跟世界细水长流 智慧用思考照明宇宙 我们懂得学问没尽头 学会怎么做事再学做人的操守 我们懂得学习的理由 吸收是为了奉献才能承先启后 生命不止坚毅与奋斗 有梦想才是有意义的追求 成功不止付出与拥有 有承担才是最高的成就 知识跟世界细水长流 智慧用思考照明宇宙 我们懂得学问没尽头 学会怎么自救再学做人的操守 我们懂得学习的理由 力量要用来分享才能承先启后 我们懂得学问没尽头 学会终身学习才没辜负一番造就 我们懂得学习的理由 活出生命的光彩才无愧于春秋 我们懂得学习的理由 活出生命的光彩 才无愧于春秋]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[第277天]]></title>
      <url>%2F2017%2F03%2F21%2FDiary_1%2F</url>
      <content type="text"><![CDATA[下雨下这么多天还真强，嗯！ 每天多学点少浪点一泄劲又得调整！ 数据结构好难！！！ 单词好容易忘！！！ 从来没有这么清楚想要什么！！ 明天加油！！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[顺序表的操作2 实现算法2.7（严蔚敏）]]></title>
      <url>%2F2017%2F03%2F21%2F%E5%AE%9E%E7%8E%B0%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%AE%97%E6%B3%952.7%2F</url>
      <content type="text"><![CDATA[实现线性表算法2.7 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140# include &lt;stdio.h&gt;# include &lt;stdlib.h&gt; //包含了exit函数 # define OVERFLOW -2 # define TURE 1# define FLASE 0# define OK 1# define ERROR 0# define LIST_INIT_SIZE 10 //线性表存储空间的初始分配量 # define LIST_INCREMENT 2typedef int ElemType; //分号不能丢 typedef int Status; void print1(ElemType a);Status ListInsert(struct Sqlist &amp;L, ElemType a, ElemType j);void ListTraverse(Sqlist &amp;L, void(* print1)(ElemType ));void InitList(Sqlist &amp;L);void MergeList(Sqlist La, Sqlist Lb, Sqlist &amp;Lc);struct Sqlist&#123; ElemType * elem; //储存空间基址 int length; //当前长度 int listsize; //当前分配的存储容量，以sizeof（ElemType）为单位 &#125;;int main(void)&#123; Sqlist La, Lb, Lc; int j; InitList(La); //创建空表La for(j = 1; j &lt;= 5; j++) &#123; ListInsert(La, j, j); //在表中插入5个元素依次为1，2，3，4，5 &#125; printf(&quot;La = &quot;); ListTraverse(La, print1); //对每个元素调用print1函数输出La的值 InitList(Lb); //创建空表b for(j = 1; j &lt;= 5; j++) &#123; ListInsert(Lb, j, j*2); //在表中插入5个元素依次为2，4，6，8，10 &#125; printf(&quot;Lb = &quot;); //输出表Lb的内容 ListTraverse(Lb, print1); MergeList(La, Lb, Lc); //由按非递减排列的表La，Lb得到按非递减排列的Lc printf(&quot;Lc = &quot;); //输出Lc的内容 ListTraverse(Lc, print1);&#125;void print1(ElemType a) //print1函数 &#123; printf(&quot;%d &quot;,a);&#125;Status ListInsert(struct Sqlist &amp;L, ElemType a, ElemType j)&#123; ElemType *q, *p, *newbase; if(a &lt; 1 || a &gt; L.length + 1) //a值不合法 return ERROR; if(L.length == L.listsize) //如果存储空间已满，则需要开辟新的空间 &#123; newbase = (ElemType *)realloc(L.elem, (L.listsize + LIST_INCREMENT) * sizeof(ElemType)); //为l.elem 追加长度 if (!newbase) exit(OVERFLOW); //分配失败 L.elem = newbase; L.listsize += LIST_INCREMENT; //增加存储容量 &#125; q = L.elem + a - 1; //q为插入位置 for(p = L.elem + L.length - 1; p &gt;= q; --p) //插入位置及以后的数据全部往后移，由表尾元素开始 &#123; *(p + 1) = *p; &#125; *q = j; L.length++; //表长加一 return OK;&#125;void InitList(Sqlist &amp;L) //算法2.3，构造一个空的顺序线性表L&#123; L.elem = (ElemType * )malloc(LIST_INIT_SIZE * sizeof(ElemType)); if(!L.elem) //存储空间分配失败 exit(OVERFLOW); //所在头文件：stdlib.h //功能: 关闭所有文件，终止正在执行的进程。 //exit(x) x==0表示正常退出，x!=0表示非正常退出 else L.length = 0; //空表长度为0 L.listsize = LIST_INIT_SIZE; //初始化存储容量 &#125;void ListTraverse(Sqlist &amp;L, void(* print1)(ElemType )) //不进行计算不要加&amp;&#123; ElemType *p = L.elem; //p指向第一个元素 int i; for(i = 1; i &lt;= L.length; i++) print1(*p++); printf(&quot;\n&quot;);&#125; void MergeList(Sqlist La, Sqlist Lb, Sqlist &amp;Lc)//1. 已知顺序线性表La和Lb的元素值按值非递减排列//2. 归并La，Lb得到新的顺序线性表Lc，Lc的值也不按非递减排列（不改变表La与Lb） &#123; ElemType *pa, *pa_last, *pb, *pb_last, *pc; pa =La.elem; //pa指向la的第一个元素 pb =Lb.elem; // pb指向lb的第一个元素 Lc.listsize = Lc.length = La.length + Lb.length; //不用InitList创建Lc pc = Lc.elem = (ElemType *)malloc(Lc.listsize * sizeof(ElemType)); if(!pc) exit(OVERFLOW); else pa_last = La.elem + La.length - 1; //指向最后一个元素 pb_last = Lb.elem + Lb.length - 1; while (pa &lt;= pa_last &amp;&amp; pb &lt;= pb_last ) //表la与表lb均有元素没有被归并 &#123; if(*pa &lt; *pb) //表la的元素不大于表lb的元素 *pc++ = *pa++; //将pa指向单元的值赋值给pc所指向的单元后，pa与pc分别加1 else *pc++ = *pb++; &#125;//以下while循环只有一个被执行 while(pa &lt;= pa_last) //表lb的元素全部被归并 *pc++ = *pa++; //插入表lb剩余元素 while(pb &lt;= pb_last) *pc++ = *pb++;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[顺序表的操作1（严蔚敏）]]></title>
      <url>%2F2017%2F03%2F20%2F%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%87%BD%E6%95%B0%E6%93%8D%E4%BD%9C(%E4%B8%A5%E8%94%9A%E6%95%8F%E7%89%88)%2F</url>
      <content type="text"><![CDATA[实现线性表多种函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301/*main2-1*/ # include &lt;stdio.h&gt;# include &lt;stdlib.h&gt; //包含了exit函数 # define OVERFLOW -2 # define TURE 1# define FLASE 0# define OK 1# define ERROR 0# define LIST_INIT_SIZE 10 //线性表存储空间的初始分配量 # define LIST_INCREMENT 2typedef int ElemType;typedef int Status; Status ListInsert(struct Sqlist &amp;L, int a, ElemType j);void InitList(Sqlist &amp;L);void print1(ElemType m);void ListTraverse(struct Sqlist L, void (* print1)(ElemType )); // 对表L中每个元素调用print1 Status ListEmpty(Sqlist L); void ClearList(Sqlist &amp;L);Status GetElem(Sqlist &amp;L, int i, ElemType &amp;e);Status LocateElem(Sqlist L, ElemType e, Status (* equal)(ElemType ,ElemType));Status equal(ElemType ,ElemType );Status PriorElem(Sqlist L,ElemType k,ElemType &amp;t);int ListLength (Sqlist L);Status NextElem (Sqlist L, ElemType cur_e, ElemType &amp;next_e);Status ListDelete(Sqlist &amp;L, int i, ElemType &amp;e);void DestroyList(Sqlist &amp;L);void db1(ElemType &amp;c);void ListTraverse2(struct Sqlist L, void (* db1)(ElemType &amp;));struct Sqlist&#123; ElemType * elem; //储存空间基址 int length; //当前长度 int listsize; //当前分配的存储容量，以sizeof（ElemType）为单位 &#125;; int main (void)&#123; struct Sqlist L; ElemType e, e0; Status i; //等价于int i； int k, j; InitList(L); printf(&quot;初始化L后，L.length = %d,L.listsize = %d,L.elem = %u\n&quot;,L.length ,L.listsize, L.elem); //%u是输入输出格式说明符,表示按unsigned int格式输入或输出数据 for(j=1; j&lt;=5; j++) i = ListInsert(L, 1 ,j); //在L的表头插入j printf(&quot;在L的表头依次插入1~5后，*L.elem = &quot;); for(j = 1; j &lt;= 5; j++) printf(&quot;%d&quot;,*(L.elem+j-1)); //依次输出表L中的元素 printf(&quot;\n调用ListTraverse()函数，依次输出表L中的元素：&quot;); ListTraverse(L, print1); //依次对表L中的元素调用print1函数（输出元素值） // 没有改变线性表L里的属性值，不必传指针类型，传变量类型即可 i = ListEmpty(L); // 检测表L是否为空 printf(&quot;L.length = %d,L.listsize = %d(不变),&quot;,L.length, L.listsize); printf(&quot;L.elem = %u(不变),L是否为空？i = %d\n&quot;,L.elem, i); ClearList(L); //清空表L i = ListEmpty(L); //再次检测表L是否为空 printf(&quot;清空L后，L.length = %d,L.listsize = %d,&quot;,L.length, L.listsize); printf(&quot;L.elem = %u,L是否为空？i = %d\n&quot;,L.elem, i); for(j=1; j&lt;=10; j++) ListInsert(L,j,j); //在L的表尾插入j printf(&quot;在L的表尾依次插入1~10后，L=&quot;); ListTraverse(L,print1); //依次输出表L中的元素 printf(&quot;L.length = %d,L.listsize = %d,L.elem = %u\n&quot;,L.length ,L.listsize, L.elem); ListInsert(L,1,0); //在表头插入0这个元素，增加存储空间 printf(&quot;在表头插入0后，L.length = %d,L.listsize = %d(改变),L.elem = %u(可能改变)\n&quot;,L.length, L.listsize, L.elem); GetElem(L,5,e); //把第五个元素赋给e printf(&quot;第五个元素的值为%d\n&quot;,e); for(j=10; j&lt;=11; j++) &#123; k = LocateElem(L, j, equal); //查找表l中与j相等的元素，并将其位序赋给k if(k) //k不为0，说明有符合条件的元素存在 printf(&quot;第%d个元素的值是%d\n&quot;,k, j); else //k=0，没有符合条件的元素 printf(&quot;没有值为%d的元素\n&quot;,j); &#125; for(j=3; j&lt;4; j++) &#123; k = LocateElem(L, j*j, equal); //查找表中是否有与j平方相等的数据 if(k) //k不为0，说明有符合条件的元素存在 printf(&quot;第%d个元素的值是%d的平方\n&quot;,k, j); else //k=0，没有符合条件的元素 printf(&quot;没有值为%d平方的元素\n&quot;,j); &#125; for(j=1; j&lt;2; j++) &#123; GetElem(L, j, e0); //把表中第j哥元素赋给e0 i = PriorElem(L,e0,e); //求e0的前驱，如果成功，赋值给e if(i==ERROR) //操作失败 printf(&quot;元素%d无前驱，&quot;,e0); else printf(&quot;元素%d的前驱为%d\n&quot;,e0,e); &#125; for(j = ListLength(L) - 1; j &lt;= ListLength(L); j++) &#123; GetElem(L, j, e0); //将表中的第j个元素赋给e0 i = NextElem(L, e0, e); //求e0的后继，如果成功将值赋给e if(i == ERROR) &#123; printf(&quot;元素%d无后继\n&quot;,e0); &#125; else printf(&quot;元素%d的后继为%d,&quot;,e0, e); &#125; k = ListLength(L); for(j = k + 1; j &gt;= k; j--) &#123; i = ListDelete(L, j, e); //删除第j个元素 if(i == ERROR) printf(&quot;删除第%d个元素失败。&quot;,j); else printf(&quot;删除第%d个元素成功，其值为%d&quot;, j, e); &#125; ListTraverse2(L, db1); //对元素调用db1函数，元素值乘2 printf(&quot;L的元素值加倍后，L = &quot;); ListTraverse(L, print1); //输出L的元素值 DestroyList(L); printf(&quot;销毁L后，L.length = %d, L.listsize = %d, L.elem = %u\n&quot;,L.length, L.listsize, L.elem); &#125; Status ListDelete(Sqlist &amp;L, int i, ElemType &amp;e) //删除第i个元素并用e返回其值 &#123; ElemType *p, *q; if(i&lt;1 || i&gt;L.length) return ERROR; else p = L.elem + i - 1; //q指向被删除的元素 e = *p; //被删除的元素值赋给e q = L.elem + L.length + 1; for(p++; p&lt;+q; p++) *(p - 1) = *p; L.length--; return OK; &#125;void ListTraverse2(struct Sqlist L, void (* db1)(ElemType &amp;)) /*指向函数的指针 对表L中每个元素调用print1 */ &#123; ElemType *p = L.elem; //p指向第一个元素 int i; for(i = 1; i &lt;= L.length; i++) db1(*p++); printf(&quot;\n&quot;);&#125; void db1(ElemType &amp;c)&#123; c *= 2;&#125;void DestroyList(Sqlist &amp;L)&#123; free(L.elem); L.elem = NULL; L.length = 0; L.listsize = 0; &#125;int ListLength (Sqlist L) //返回L中数据元素的个数 &#123; return L.length;&#125;Status NextElem (Sqlist L, ElemType cur_e, ElemType &amp;next_e)/* 若cur_e是L中的元素，且不是最后一个，则用next_e返回他的后继 否则操作失败，next_e无定义 */&#123; int i = 1; ElemType *p = L.elem; //p指向第一个元素 while(i &lt;= L.length &amp;&amp; *p != cur_e) //i未到表尾且没有找到值为cur_e的元素 &#123; p++; //p指向下一个元素 i++; //计数加1 &#125; if(i == L.length) return ERROR; //操作失败 else //找到值为cur_e的元素，并由p指向其 &#123; next_e = *++p; //p指向下一个元素即后继 return OK; &#125; &#125; Status PriorElem(Sqlist L,ElemType k,ElemType &amp;t)&#123; int i = 2; ElemType * p = L.elem + 1; //p指向第二个元素 while(i&lt;=L.length &amp;&amp; * p != k) //在表长范围内且未找到eo的元素 &#123; p++; i++; &#125; if(i&gt;L.length) return ERROR; else //找到了值为e0的元素 &#123; t = *p-- ; return OK; &#125; &#125;Status equal(ElemType a,ElemType s)&#123; if(a == s) return TURE; else return FLASE;&#125;Status LocateElem(Sqlist L, ElemType e, Status (* equal)(ElemType ,ElemType))&#123; int i = 1; ElemType * p = L.elem; //p的初始值为第一个元素地址 while(i&lt;=L.length &amp;&amp; !equal(*p++,e)) //i未超出表的范围并且没找到符合条件的数据 i++; if(i&lt;=L.length) //找到了符合条件的数据 return i; //返回位序i else return 0; &#125;Status GetElem(Sqlist &amp;L, int i, ElemType &amp;e) //要改变e的值必须发送地址 &#123; if(i&lt;1 || i&gt;L.length) //i不在表L的范围内 return ERROR; else e = *(L.elem + i - 1); return OK;&#125; void ClearList(Sqlist &amp;L) //将表l置为空表 &#123; L.length = 0;&#125;Status ListEmpty(Sqlist L) //如果L为空表，则返回TURE 否则返回FLASE &#123; if(L.length == 0) return TURE; else return FLASE;&#125; void print1(ElemType m) //print1函数 &#123; printf(&quot;%d &quot;,m);&#125;void ListTraverse(struct Sqlist L, void (* print1)(ElemType ) ) /*指向函数的指针 对表L中每个元素调用print1 */ &#123; ElemType *p = L.elem; //p指向第一个元素 int i; for(i = 1; i &lt;= L.length; i++) print1(*p++); printf(&quot;\n&quot;);&#125; Status ListInsert(struct Sqlist &amp;L, ElemType a, ElemType j)&#123; ElemType *q, *p, *newbase; if(a &lt; 1 || a &gt; L.length + 1) //a值不合法 return ERROR; if(L.length == L.listsize) //如果存储空间已满，则需要开辟新的空间 &#123; newbase = (ElemType *)realloc(L.elem, (L.listsize + LIST_INCREMENT) * sizeof(ElemType)); //为l.elem 追加长度 if (!newbase) exit(OVERFLOW); //分配失败 L.elem = newbase; L.listsize += LIST_INCREMENT; //增加存储容量 &#125; q = L.elem + a - 1; //q为插入位置 for(p = L.elem + L.length - 1; p &gt;= q; --p) //插入位置及以后的数据全部往后移，由表尾元素开始 &#123; *(p + 1) = *p; &#125; *q = j; L.length++; //表长加一 return OK;&#125;void InitList(Sqlist &amp;L) //算法2.3，构造一个空的顺序线性表L&#123; L.elem = (ElemType * )malloc(LIST_INIT_SIZE * sizeof(ElemType)); if(!L.elem) //存储空间分配失败 exit(OVERFLOW); /* 所在头文件：stdlib.h 功能: 关闭所有文件，终止正在执行的进程。 exit(x) x==0表示正常退出，x!=0表示非正常退出 */ else L.length = 0; //空表长度为0 L.listsize = LIST_INIT_SIZE; //初始化存储容量 &#125;]]></content>
    </entry>

    
  
  
</search>
